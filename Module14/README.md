
4.（选做）针对课上讲解的内容，自己动手设计一个高并发的秒杀系统，讲架构图， 设计文档等，提交到 GitHub。

需求分析

什么是秒杀
秒杀场景一般会在电商网站举行一些活动或者节假日在12306网站上抢票时遇到。对于电商网站中一些稀缺或者特价商品，电商网站一般会在约定时间点对其进行限量销售，因为这些商品的特殊性，会吸引大量用户前来抢购，并且会在约定的时间点同时在秒杀页面进行抢购。如本例中的银行产品。

秒杀系统场景特点
秒杀时大量用户会在同一时间同时进行抢购，网站瞬时访问流量激增。
秒杀一般是访问请求数量远远大于库存数量，只有少部分用户能够秒杀成功。
秒杀业务流程比较简单，一般就是下订单减库存。

银行产品秒杀系统技术要求：
高并发：秒杀时大量用户会在同一时间同时进行抢购，网站瞬时访问流量激增。是时间极短、瞬间用户量极大。面对瞬间的流量涌入，如何保证服务还能平稳运行。
超卖：高效益的产品不可能无限量供应，在总额度有限的前提下，如果发生超卖的情况，不仅会损失金钱，也会引发用户投诉，降低我行用户口碑。
恶意请求：对于恶意的请求，即便不法用户最后未能抢到商品，但在恶意请求的期间，这种行为也会给服务器、数据库、带宽等造成压力，导致其他用户验下降，对于脚本等恶意行为应该迅速拦截。
数据库：项目使用 MySql 数据库，在高 QPS 的场景下，如果流量瞬间涌入数据库后让数据库挂掉，导致其他服务也无法使用，带来的灾难将是不可预估的。
链接暴露：为了防止不法分子提前知道秒杀活动的地址并发起请求，需设计一个随机算法生成秒杀链接。

设计文档

实现方案

1：限流
    将请求拦截在系统上游，降低下游压力

2：异步处理，消息队列-削峰
    实现削峰的常用的方法有利用缓存和消息中间件等技术。消息队列可以削峰，将拦截大量并发请求，这也是一个异步处理过程，后台业务根据自己的处理能力，从消息队列中主动的拉取请求消息进行业务处理

3：缓存
    秒杀系统最大的瓶颈一般都是数据库读写，由于数据库读写属于磁盘IO，性能很低，如果能够把部分数据或业务逻辑转移到内存缓存，效率会有极大地提升。‘
    
4：分布式
Redis Cluster

架构图

![Pasted Graphic](https://user-images.githubusercontent.com/10376496/183284863-7a8384b3-2c53-437a-b3e3-5d50c8f13ee4.jpg)


基本思路为前端对请求进行限流，然后服务请求通过redis缓存来控制秒杀请求是否成功，然后将成功请求放入MQ，MQ逐步调用数据库去处理订单。通过限流，分布式缓存和异步队列的方式来分摊流量压力。下面是前端和后端的具体实现方案。


前端：
秒杀开始前，秒杀按钮灰掉为“未开始”，不可点击。
在秒杀进行中，秒杀按钮才可以点击下单。
秒杀产品的介绍，详情，参数等等，全部静态化，将秒杀商品页面缓存在CDN上（资源没那么好其实可以放在Nginx中做动静分离）CDN服务器就是内容分发网络，把资源内容放在了全国各地的各服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容。（一般都是到阿里云买CDN服务器）
用户点击“下单”后，按钮置灰，禁止用户重复提交请求，限制用户在60秒之内只能提交一次请求。（防止DDOS攻击）
然后就发送请求了，请求统一发送到Nginx中。

后端：
Nginx收到前端的请求后，在进行限流操作后才把前端秒杀的请求发送到Tomcat服务器上的秒杀接口上。也就是说：这Nginx转发请求到tomcat的层到途中：Nginx限制用户的重复提交，使用了限流在某一时间段内只允许用户提交一次请求到秒杀接口（重点）

为什么要Nginx限流：Nginx限流就是限制用户请求速度，防止服务器受不了（防止DDOS攻击）重点：Nginx配置的限流代码。
Nginx限流有3种
1、限制访问频率（正常流量）
2、限制访问频率（突发流量）
3、限制并发连接数

然后到了秒杀接口上了，这个秒杀接口的项目在启动运行的时候就把商品id和数量保存到了 Redis中，秒杀项目启动时的操作，把商品id和数量保存到了 Redis中，（我们考Redis来解压力，防止服务器和数MySql受不了）
项目运行流程先做唯一性判断,对uid进行请求计数和去重，发现以经发送过秒杀请求就结束秒杀。万一人家不通过Nginx进来秒杀怎么办，直接访问秒杀接口（所以需要再次判断Uid）
再次（防止DDOS攻击）
然后请求到达时通过要秒杀的id号到Redis中去查询预减库存，只要商品库存不到0就执 行下一步，(因为Redis的操作是具有原子性所以不会出现超卖的问题）（重点）
关键的decr方法（redis中的原子递减，根据key减value值）decr key将指定key的value原子性递减1，就相当于java中的–i。 如果该key不存在，其 初始值为0，在decr之后其值为-1。如果value的值不能转成整型，如helllo，该操作将 执行失败并返回相应的错误信息。

然后在把订单消息传入MQ，MQ去通知下单接口生成订单，这个MQ实现了流量削峰后在以先进先出的方式进行异步下 单（前期都没操作数据库，防止服务器压力太大会死机的，，经过MQ之后才访问数据库）
注意：（可以不需要此MQ，此MQ只是在分布式项目中需要，就是下单接口在另外的项目就需要，要此MQ还不好，因为中间插件挂了秒杀系统也挂了，其实可以直接调用下单的方法了）
如果就在此接口下单的话就只需要调用下单接口生成订单就好了，不需要中间插件了。

下单的过程中的SQL语句还使用了乐观锁进行操作的再次控制防止出现超卖现象,（其实可以不需要，只是保证以下，其实可以直接生成下单的订单了）
乐观锁的标记值判断就是把redis中返回预减后的的值去和数据库的库存去判断，达到一个防止超卖的现象。
到此秒杀结束。


Reference

https://blog.csdn.net/muchen1012/article/details/121430714

https://blog.csdn.net/qq_24892029/article/details/112941020

